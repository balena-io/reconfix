use std::{env, process::Command};

fn main() {
    let go_cmd = env::var("GO").unwrap_or_else(|_| "go".to_string());
    let out_dir = env::var("OUT_DIR").unwrap();

    println!("cargo:rerun-if-env-changed=GO");

    if env::var("CARGO_CFG_TARGET_ARCH").unwrap() != "wasm32" {
        let code = Command::new(go_cmd)
            .current_dir("c")
            .env("CGO_ENABLED", "1")
            .args(&[
                "build",
                "-buildmode",
                "c-archive",
                "-x",
                "-o",
                &format!("{}/{}", out_dir, "libcuelang-sys.a"),
            ])
            .status()
            .expect("failed to run go");
        if !code.success() {
            panic!("failed to compile FFI code");
        }

        // Build Rust bindings using the header file generated by go
        bindgen::builder()
            .header(format!("{}/{}", out_dir, "libcuelang-sys.h"))
            .generate()
            .expect("failed to generate bindings")
            .write_to_file(format!("{}/{}", out_dir, "go.rs"))
            .expect("failed to write bindings module");

        println!("cargo:rerun-if-changed=c/ffi.go");
        println!("cargo:rustc-link-search={}", out_dir);
        println!("cargo:rustc-link-lib=static=cuelang-sys");
    } else {
        let code = Command::new(go_cmd)
            .envs(vec![("GOOS", "js"), ("GOARCH", "wasm")])
            .args(&[
                "build",
                "-x",
                "-o",
                &format!("{}/{}", out_dir, "cuelang-sys.wasm"),
                "wasm/ffi.go",
            ])
            .status()
            .expect("failed to run go");
        if !code.success() {
            panic!("failed to compile FFI code");
        }

        println!("cargo:rerun-if-changed=wasm/ffi.go");
    }
}
